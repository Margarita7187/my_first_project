1. Функциональные компоненты используют хуки для состояния и жизненного цикла, они проще и современнее. Классовые компоненты используют методы жизненного цикла и this.state. Следует использовать функциональные компоненты для нового кода, классовые — только для поддержки существующих проектов.

2. Props — это данные, передаваемые от родителя к дочернему компоненту (только для чтения). State — внутреннее состояние компонента, которое можно изменять. Props изменяются извне, state управляется внутри компонента.

3. Поднятие состояния — перенос состояния в ближайшего общего родителя, когда несколько компонентов должны использовать одни и те же данные. Это необходимо для синхронизации состояния между компонентами.

4. componentDidMount — после монтирования, componentDidUpdate — после обновления, componentWillUnmount — перед размонтированием, shouldComponentUpdate — для оптимизации рендеринга.

5. useState — хук для управления состоянием, возвращает значение и функцию для его обновления. useEffect — хук для побочных эффектов (запросы, подписки). Правила: вызывать хуки только на верхнем уровне и только в функциональных компонентах.

6. Ключи (keys) помогают React идентифицировать элементы в списке при изменениях. Они важны для производительности и корректного обновления списка.

7. В React события обрабатываются через camelCase-атрибуты (например, onClick), используется синтетическая система событий для кроссбраузерности. В отличие от нативного JS, нельзя вернуть false для отмены события.

8. Управляемые компоненты получают значение через props и уведомляют об изменениях через колбэки. Неуправляемые компоненты хранят состояние в DOM (через ref). Управляемые компоненты предпочтительнее для контроля данных.

9. Контекст (Context) позволяет передавать данные через дерево компонентов без пропсов на каждом уровне. Его следует использовать для глобальных данных (тема, пользователь, настройки), но не заменять пропсы без необходимости.

10. Кастомные хуки позволяют переиспользовать логику состояния между компонентами. Они создаются как функции, начинающиеся с use, и могут вызывать другие хуки. Преимущества: переиспользование логики, чистые компоненты, удобство тестирования.