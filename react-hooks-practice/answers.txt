1. useState для простого состояния, useReducer для сложной логики с множественными значениями. useReducer лучше когда следующее состояние зависит от предыдущего или есть сложные правила обновления.

2. Массив зависимостей определяет когда эффект запускается. Пустой массив [] - только при монтировании. Без массива - при каждом рендере. Если не указать - эффект выполняется после каждого рендера.

3. Stale closure - когда функция внутри хука использует устаревшие значения переменных. Решение - функциональные обновления для useState или использование рефов для актуальных значений.

4. useCallback для мемоизации функций, useMemo для вычислений. Нужны когда передаются вложенным компонентам или тяжелые вычисления. Часто являются преждевременной оптимизацией если нет реальных проблем.

5. useRef хранит мутируемое значение без перерендера, useState вызывает перерендер при изменении. useRef незаменим для доступа к DOM, хранения таймеров, значений не влияющих на рендер.

6. Правила: вызывать хуки только на верхнем уровне и только в React-функциях. Нарушение ломает порядок вызова хуков и приводит к багам.

7. Кастомный хук - функция начинающаяся с use, может использовать другие хуки. Лучшие практики: четкое назначение, возврат понятного API, следование правилам хуков.

8. useContext упрощает передачу данных через уровни, избавляет от "prop drilling". Но усложняет отслеживание потока данных по сравнению с пропсами.

9. Асинхронные операции в хуках обрабатываются через useEffect, очистка через abort controller или флаги. Важно обрабатывать состояние загрузки и ошибок.

10. Отладка через React DevTools, console.log внутри эффектов, использование useDebugValue для кастомных хуков, анализ стека вызовов в инструментах разработчика.