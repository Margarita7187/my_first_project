1. Временная сложность O(n) означает линейную зависимость времени выполнения от размера входных данных, пример - поиск в неотсортированном массиве. O(n²) означает квадратичную зависимость, пример - пузырьковая сортировка.

2. Бинарный поиск работает путем деления отсортированного массива пополам на каждой итерации, отбрасывая одну из половин. Сложность O(log n) потому что на каждом шаге область поиска уменьшается вдвое.

3. Преимущества пузырьковой сортировки: простота реализации, стабильность. Недостатки: низкая производительность O(n²), неэффективна для больших массивов.

4. Для оптимизации проверки простоты числа можно проверять делители только до квадратного корня числа, пропускать четные числа после проверки двойки.

5. Рекурсивная реализация Фибоначчи проще но имеет экспоненциальную сложность, итеративная эффективнее с линейной сложностью но сложнее в реализации.

6. Для отладки использовал console.assert для проверки ожидаемых результатов, console.log для промежуточных значений и инструменты разработчика браузера.

7. Алгоритм Евклида основан на том что НОД(a,b) = НОД(b,a mod b). Эффективен потому что на каждой итерации числа уменьшаются.

8. Крайние случаи для массивов: пустой массив, массив с одним элементом, массив с одинаковыми элементами, очень большой массив.

9. Для улучшения удаления дубликатов из больших массивов можно использовать Set который обеспечивает постоянное время проверки наличия элемента.

10. Принципы чистого кода: понятные имена переменных, одна ответственность у функций, избегание побочных эффектов, комментарии для сложных алгоритмов.